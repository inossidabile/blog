<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Joosy | Staal Forge]]></title>
  <link href="http://archive.staal.io/blog/categories/joosy/atom.xml" rel="self"/>
  <link href="http://archive.staal.io/"/>
  <updated>2014-02-12T00:24:08+07:00</updated>
  <id>http://archive.staal.io/</id>
  <author>
    <name><![CDATA[Boris Staal]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[2-Way Data Binding under the Microscope]]></title>
    <link href="http://archive.staal.io/blog/2014/02/05/2-way-data-binding-under-the-microscope/"/>
    <updated>2014-02-05T23:43:00+07:00</updated>
    <id>http://archive.staal.io/blog/2014/02/05/2-way-data-binding-under-the-microscope</id>
    <content type="html"><![CDATA[<p>2-way data binding has entrenched modern front-end development as a tool allowing you to avoid boilerplate code when working with DOM, concentrate on logic and isolate the logic from your templates. All the Angular is built around this piece of technology. Pretty big part of Ember joins that. And for the Backbone framework there are numerous extensions appearing every day. It makes a lot of sense actually: 2-way data binding is pretty awesome. However the technology has its own issues, limitations and mostly important implementation details (within different frameworks). Why not speculate about it a little bit?</p>

<!-- more -->


<h3>What is 2-way data binding after all?</h3>

<p>JavaScript allows you to build interaction with a user responding to his actions with visual events. User enters some data into a form, presses &ldquo;submit&rdquo; button and a page shows loading indicator. Then (given the input contained some kind of error) invalidated fields get highlighted.</p>

<p>What&rsquo;s happening behind the scenes?</p>

<ul>
<li>values of fields get stored into a variable</li>
<li>variable gets serialized into JSON and gets sent onto server with an AJAX query</li>
<li>DOM gets modified: loading indicator appears</li>
<li>as soon as the request finishes we see that status is not 200, then we parse response body</li>
<li>DOM gets modified again: loading indicator disappears, invalidated fields get highlighted</li>
</ul>


<p>Classical jQuery code could work similarly to this:</p>

<ol>
<li> a function gets attached to the &lsquo;click&rsquo; event of button</li>
<li> the functon collects fields and puts them into a variable</li>
<li> the variables gets serialized into JSON and goes to server</li>
<li> we mark &ldquo;request in process&rdquo; state using another variable (to not react double clicks mainly)</li>
<li> we modify DOM adding indicator</li>
<li> as soon as the request finihes we parse response body and get invalidation data</li>
<li> we modify DOM adding invalidation information and removing the loading indicator</li>
</ol>


<blockquote><p>Note that step 7 has huge risk of the encapsulation violation: we modify our view heavily. Where should this logic be? How to avoid duplication of code with something that generated the form initially? Basically it&rsquo;s the most popular place for projects to turn into mess.</p></blockquote>

<p>2-way data binding lets us get rid of steps 2, 5 and 7. It also solves the issue with the encapsulation or – as it&rsquo;s trendy to think now – alows you to completely remove logic from your views.</p>

<p>Given we have a variable called <code>entity</code> holding JavaScript object. Each field of the form is associated with the attribute of the object (i.e. <code>&lt;input name='name'&gt;</code> with <code>entity.name</code>). At the same time the variable can include inlined object <code>entity.errors</code> containing invalidations list (it&rsquo;s empty by default). Then if we want to invalidate field <code>entity.name</code> we are doing something similar to <code>entity.errors.name = 'The field is too short'</code>. Additionally we set <code>entity.loading</code> to <code>true</code> when our AJAX is in progress.</p>

<p>To turn such object into required form we could use a template looking like this (<a href="http://underscorejs.org/#template">Underscore Template</a> notation):</p>

<p>```html
&lt;% if (entity.errors.name) { %></p>

<div class="error">
<% } %>
  <input name="name" value="<%= entity.name %>">
<% if (entity.errors.name) { %>
<%= entity.errors.name %>
</div>


<p>&lt;% } %>
&lt;% if (entity.loading) { %>
Sending form&hellip;
&lt;% } else {
<button>Send!</button>
&lt;% } %>
```</p>

<p>Now if any change of form input automatically got delivered to <code>entity.name</code> and vice versa any change of any attribute at <code>entity</code> caused automatic refresh of DOM according to template definition – that would be the 2-way data binding. Your template completely describes the display logic corresponding to possible states. The application in its turn simply changes states.</p>

<p>All we have to do now is to bind form submission to button click event and work with <code>entity</code> variable. When the server responds – we put all the validation errors into <code>entity.errors</code>. That&rsquo;s it. Much easier isn&rsquo;t it?</p>

<h3>Actually no. It is not.</h3>

<p>Unfortunately it is just an example. In real-life it misses a vast amount of meta-inforation that it simply can&rsquo;t work without. To make it work universally we have to solve the following problems:</p>

<ul>
<li>we have to find a way to monitor <code>entity</code> modifications recursively. You remember it&rsquo;s still plain old JavaScript right?</li>
<li>we can&rsquo;t monitor all the modifications for all the variables and constantly redraw the whole DOM of the page. In best case it will end up being extremely slow. Otherwise it can lead to the loss of state of DOM parts. DOM should be modified as atomically as possible.</li>
<li>even if we section our page in zones, what&rsquo;s going to happen if we need to replace the part of text content not touching its siblings? Or how do you update (including the tag itself) two <code>&lt;tr&gt;</code>s out of 10?</li>
<li>sometimes we might want to animate automatic modifications instead of changing DOM instantly</li>
<li>we don&rsquo;t currently have the reflection of <code>input</code> to <code>entity.name</code>. We imagined having that but how do we actually implement that? Where is this logic supposed to be situated? At the application code with <code>bind</code> or at the view itself where the reverse binding is described?</li>
</ul>


<p>To solve all that every framework offers its own unique solutions that add fly in the ointment to a beautiful theory. So let&rsquo;s dive in and see how 2-way data binding actually works internally and where do all those weird limitations come from?</p>

<p>We are going to dig into 3 examples: <a href="http://angularjs.org">Angular</a> as a canonical sample of &ldquo;new and better HTML&rdquo;, <a href="http://emberjs.com">Ember</a> as a sample of more classical JS paradigm attached to the new tool. And certainly <a href="http://joosy.ws">Joosy</a> as a demonstration of my subjective vision of experimental 2-way data binding that doesn&rsquo;t require declarative templating language.</p>

<h3>Object modifications monitoring</h3>

<p>Sadly there are no good univeral ways to track objects modifications in JavaScript. All the existing solutions impose some restrictions on how you work with the object. There actually exactly two solutions: wrapping with setters/getters and external monitoring.</p>

<h4>Setters/Getters (Ember, Joosy)</h4>

<p>Properties working through getters and setters are the classic of programming. All the required data types get wrapped into extending classes (types) definining two methods: <code>get</code> and <code>set</code> (or two methods per property). Every call to the <code>set</code> method makes object generate &ldquo;something has changed&rdquo; event. The solution is very simple technically and for obvious reasons quite efficient. However instead of <code>entity.field = 'value'</code> you have to write <code>entity.set('field', 'value')</code>. The latter is not only less readable by a human being but also can affect some basic tools like <a href="http://www.javascriptlint.com">JavaScript Lint</a> and code highlighting.</p>

<h5>Ember</h5>

<p>Getters and setters are the root of Ember&rsquo;s properties system. Not only they allow to monitor object modifications but also allow you to subscribe to the modifications of particular fields. Basically it looks exactly as described:</p>

<p><code>javascript
entity.set('field', 'value')             // Object field
entity.set('field.subfield', 'value')    // Subobject field
</code></p>

<p>On the other hand when we get to arrays (that Ember generalizes into <code>Enumerable</code>) everything gets a little bit more complicated and confusing. Now we have to additionally watch the length of array and also provide the ability to monitor changes of particular fied of every entry (Ember allows doing that using meta property called <code>@each</code>: for instance <code>@each.field</code> to monitor change of <code>field</code> for every array entry).</p>

<blockquote><p>If you watch the history of how frameworks evolve you will see one funny repeating loop. Complicated frameworks a-la Rails appear, take over the market and then get split into separate independent components. Components that can be used separately. That is often used to build variety of similar frameworks based on similar technologies. Watchable objects library could be the perfect candidate to become an independent library with a separate API.</p></blockquote>

<h5>Joosy</h5>

<p>Getters and setters for objects work identically in Joosy. Excluding the fact that Joosy doesn&rsquo;t have inline fields monitoring. That&rsquo;s why arrays work simpler:</p>

<p><code>coffeescript
collection = new Joosy.Resources.Array
collection.set(0, 'value')                # Index-based
collection.push('another value')          # Basic array actions
</code></p>

<p>Besides that Joosy mimics Ruby allowing you to additionaly define direct accessors for properties.</p>

<p><code>coffeescript
class Entity extends Joosy.Resources.Hash
  @attrAccessor 'field1', {'field2': ['subfield1', 'subfield2']}
</code></p>

<p>Such definition will force Joosy to create JavaScrpipt object properties with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>defineProperty</code></a> allowing you to work with them as if they were normal attributes: <code>entity.field1</code>. Therefore you can get back to <code>entity.field1 = 'value'</code> instead of <code>entity.set('field1', 'value')</code> – these are now equal. With this you have to manually define the list of fields, yes, but you get your proper JavaScript syntax back.</p>

<h4>External monitoring (Angular)</h4>

<p>Angular took its own approch. Instead of attempts to catch attributes modifications from the internals of the object it introduces the global monitoring system. The famous <code>$watch</code> method that is overabused in every second Angular application.</p>

<p>Angular architecture introduces &ldquo;drawing cycle&rdquo;. One of its step is the check against the list of watchers if there are any changes. Every element of the list can refer to one or more functions that are called upon every change. Such solition allows you to transparently work with any way of attributes modifications (no need to know the list of fields or use the <code>set</code> method). This however is not a silver bullet as well.</p>

<ol>
<li><p> <strong>Performance</strong></p>

<p>If you used to work with Angular you probably noticed that after the particular amount of active <code>$watch</code> assignments everthing slows down critically. The more mobile your client is (and we are living in the mobile technologies epoch) the faster you get to this amount. Performance is the first payment for universalism.</p></li>
<li><p> <strong>Non-scalars</strong></p>

<p>By default the modification check is being held by reference. It means that no matter how you change your array or object Angular is not going to see the change. One of the solutions to this problem is additional mode of <code>$watch</code> that allows you to force value-based comparison. It however is even slower. The other problem is that it still might not always work with complicated structures. On the other hand it&rsquo;s not a normal case when you need to monitor something like that in Angular: its architecture tries to avoid the need to monitor non-scalar data as much as possible.</p></li>
</ol>


<p>Protip: try to search for <code>angular watch</code> <a href="http://stackoverflow.com/search?q=angular+watch">at StackOverflow.com</a> to understand the scale of the disaster.</p>

<h3>Page sectioning</h3>

<p>Now that we can catch objects modifications the time has come to decide how we segment the page. What exactly are we going to update when object changes? Clearly if we output <code>entity.name</code> field for instance – we only have to update that value and only when it&rsquo;s changed. What if we output a table in cycle though?</p>

<h4>Declarative templates (Angular, Ember)</h4>

<p>This is one of the reasons making Angular to have &ldquo;the other HTML&rdquo; and making Ebmer to have Handlebars. Declarative description that is being parsed by their own internal parsers provides information about contexts of the bindings.</p>

<p>When we output <code>{{person.first_name}}</code>, Ember creates a region and attaches that to the updae of <code>first_name</code> field from the <code>person</code> object. Angular works similarly: <code>&lt;ng_repeat ...</code> creates a common region for the whole array and additionaly one inner region per each array element. If the array changes – the bigger region redraws. If one of the elements changes – the inner region redraws.</p>

<p>The conditional declarations (<code>ng_if</code> and <code>{{if}}</code>) work in the same way. As soon as value is changed all the region redraws].</p>

<blockquote><p>This by the way is one of the reasons that makes Angular recomdend to prefer <code>ng_show</code> hiding the region instead of rerendering it.</p></blockquote>

<p>Devise of this approach is: &ldquo;templates should not contain logic!&rdquo;. This however looks more like a consequence than a rule. Integration of full logical language into such declarative notation would be extremely expensive. So the wolves are fed and the sheep kept safe. We don&rsquo;t need language and we achieve the ultimate theoretical goal. Isn&rsquo;t that great?</p>

<p>Reality is tough though. Logic can&rsquo;t just disappear, it has to move somewhere. If it&rsquo;s not at template in any way – it should be defined somewhere as a state. It means that every little feature will add one more virtual state to your application. Loading indicators, accessibility rules, selection marks, each tiny switcher. The understanding of how serious this tax can be can come too late since you normally add tiny visual features at the very end of the project when you can&rsquo;t just switch the approach.</p>

<h4>Manual sectioning (Joosy)</h4>

<p>I always wanted to keep my beloved HAML (mixed <a href="https://github.com/netzpirat/haml-coffee">with CoffeeScript</a>) and at the same time to keep all the abilities of 2-way data binding. To achieve that Joosy implements manual sectioning. Instead of declarative definitions we use classical helpers. One of them for instance allows you to define dynamic region and pass it the local data that this region will watch for.</p>

<p>E.g. to get the behavior similar to <code>ng_repeat</code> of Angular or to <code>each</code> of Ember you can do something like this:</p>

<p>```haml
%ul
  != @renderInline {projects: @projects}, &ndash;></p>

<pre><code>- for project in @projects
  %li= project.name
</code></pre>

<p>```</p>

<p>As soon as the <code>@projects</code> array or any of its elements change the modification immediately applies to DOM. Note that region watchers expressly implemented to monitor collections with all the nested values. That&rsquo;s why you only need one segment in this case.</p>

<p>Besides inlining Joosy allows you to render a partial (just like in Rails) as a region. This case is even more common.</p>

<p>This approach gives you ability to work with any templating language you want. Any notation is fine (Joosy currently supports any templating language compilable by JST). The other benefit is ability to control rendering manually (for instance you can bind a region to the resource that is not outputed explicitly) which might sound destructive but can be useful rarely.</p>

<p>The cons of this approach are the flip side of pros. Not only you can control everything – you actually have to. No regions defined – no 2-way data binding. The other problem is the case with <em>huge</em> regions (1000 rows per table). Since Joosy registeres just one region per array, any modification will alway redraw the whole table. Even worse – you can&rsquo;t really define a region depending on a particular field. It only accepts a whole resource. This can be painfull when it comes to complicated forms.</p>

<h3>Partial DOM updates</h3>

<p>Now that we have sections with binding to proper local sets of objects that redraw automatically. Life is getting better. There&rsquo;s however a new problem to solve:</p>

<p>```html
Text</p>

<!-- region -->


<p>Another Text<!-- /region -->
And some more text
```</p>

<p>What if our region is not entirely a tag content and it can&rsquo;t be modified with the usage of <code>.innerHTML</code>?</p>

<h4>Metamorph (Ember, Joosy)</h4>

<p>Ember and Joosy are on the same page here. We wrote separate solution initialy but ended up using the library <a href="https://github.com/tomhuda/metamorph.js/">Metamorph</a> created by Ember team. And Metamorph works pretty well.</p>

<p>When working in modern browsers Metamorph relies on <a href="http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html">W3C Ranges</a>. For the old browsers everything gets much more interesting. Region gets wrapped into two <code>script</code> tags that, according to specification, can be part of any other tags. To update content Metamorph replaces the content between these two tags.</p>

<h4>Angular</h4>

<p>Since Angular&rsquo;s approach is based on the &ldquo;better HTML&rdquo; – it&rsquo;s task is a little bit different. In most cases we simply bind to a particular tag so Angular basicly doesn&rsquo;t have this problem. The only similar case it has is the interpolation. During interpolation Angular binds everything to the closest parent tag and turns it into a region. Thus Angular alway modifies only tags and attributes of tags. No magic.</p>

<h4>Another interesting approach</h4>

<p>There&rsquo;s one more interesting approach that I saw implemented by tiny frameworks (mostly implementing just the binding itself). This approach was also mentioned by Yehuda Katz to become a replacement for Metamorph. Instead of interpreting HTML as a text it makes you to parse it and convert it into direct DOM statements:</p>

<p><code>javascript
// Taken from: https://gist.github.com/wycats/8116673
var output = dom.createDocumentFragment();
var a = dom.createElement('a');
dom.RESOLVE_ATTR(context, a, 'href', 'url');
var text = dom.createTextNode();
dom.RESOLVE(context, text, 'textContent', 'link');
a.appendChild(text);
output.appendChild(a);
</code></p>

<h3>Animations</h3>

<h4>CSS-classes (Angular)</h4>

<p>Since Angular always works on a tag level – it always has a container to interact with. This is a huge advantage when it comes to animations. During the modificaiton of DOM Angular sets special CSS classes to the changing tag. This allows you to easily add CSS-based transitions and animations with no additional code.</p>

<p>Angular also contains additional tools allowing you to bind JS animations to particular CSS classes. Seriously, Angular is amazing when it comes to animations. Some limitations in other areas seriously simplify everything here.</p>

<h4>Numerous issues (Ember, Joosy)</h4>

<p>Metamorph is on the other page. Everything is much more sad – our regions are not bound to DOM in any way and it&rsquo;s unclear what should be animated during modification. There are numerous proposals for Ember syntax like <code>{{if flag transition='fade'}}</code>. However they don&rsquo;t look realistic with the current implementation of Handlebars. You simply can&rsquo;t animate random DOM region having no single root.</p>

<p>You could probably explicitly pass the ID of element to animate as addition to the animation style. This however seriously breaks conventions of Ember declarative language. I&rsquo;m really excited to monitor all the discussions regarding this topic but it doesn&rsquo;t look like it&rsquo;s on the priority list of Ember right now.</p>

<p>Joosy is in the similar situation here. It has a little advantage with the fact we work with JS code straightly (CoffeScript code to be more correct). That&rsquo;s why it&rsquo;s not limited to strings and can pass JS function directly. So basically we can hook into the rendering internals.</p>

<p><code>haml
!= @renderInline {entity: @entity}, @animation, -&gt;
</code></p>

<p>I don&rsquo;t think it&rsquo;s a proper solution as well but at least it works. We are currently considering allowing you to pass in the selector and animation keyword as described before:</p>

<p><code>haml
!= @renderInline {entity: @entity}, ['#selector', 'fade'], -&gt;
</code></p>

<h3>Reverse binding (inputs to fields of objects)</h3>

<p>The last step to bright future is the reverse binding. Automatically changing the fields of objects during the modifications of form fields. Having all our experience it&rsquo;s a piece of cake. Angular and Ember having declarative templates simply add another attribute specifying which field should be mapped:</p>

<p><code>html
&lt;input ng-model='entity.field'&gt; &lt;!-- Angular --&gt;
{{input value=entity.field}}    &lt;!-- Ember --&gt;
</code></p>

<p>Joosy implements the same with set of helpers:</p>

<p><code>haml
!= @formFor @entity, (f) -&gt;
  != @f.input 'field'
</code></p>

<p>Finally we got the 2-way binding working!</p>

<h3>Instead of conclusion</h3>

<p>As you can see there are numerous ways to implement 2-way data binding. While declarative languages (including separate languages like Handlebars and HTML extensions) masterfully dominate, there are other options as well. None of them works perfectly though. Generally this is what all the &ldquo;modern&rdquo; tools go through and I&rsquo;m sure we will come up with more elegant ways of solving the described issues. We are still waiting for tons of exciting HTML features to get accessible and even more to be defined (like <a href="http://www.polymer-project.org/platform/node_bind.html">Node.bind()</a>).</p>

<p>Be careful until we there though. 2-way data binding is an amazing tool. But the drawbacks can be essential. Make sure to discover them as soon as possible: hopefully you just got one step closer to this.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Incredibly convenient testing of front-end Javascript with Node.js]]></title>
    <link href="http://archive.staal.io/blog/2013/08/17/incredibly-convenient-testing-of-frontend-javascript-with-node-dot-js/"/>
    <updated>2013-08-17T23:28:00+07:00</updated>
    <id>http://archive.staal.io/blog/2013/08/17/incredibly-convenient-testing-of-frontend-javascript-with-node-dot-js</id>
    <content type="html"><![CDATA[<p>You do have automated testing for your front-end Javascript application / library / framework don&rsquo;t you? And tests work equally well at console, browsers and Travis aren&rsquo;t they? And you run them in every possible browser on each release (or even push) right? If the answer is no, you might be doing it wrong. Let&rsquo;s see if we can do something about it!</p>

<p>This article briefly describes a little piece of theory behind testing of standalone front-end projects, issues that you are likely to meet and the solution I came up with. Here&rsquo;s the shortcut <a href="https://github.com/inossidabile/grunt-contrib-testem">https://github.com/inossidabile/grunt-contrib-testem</a> if you are already bored so far ;).</p>

<!-- more -->


<h3>Part 1. Introduction</h3>

<blockquote><p>If you know what Jasmine, Mocha, PhantomJS and Grunt are, skip to Part 2.</p></blockquote>

<p>When it comes to testing, the first question is &mdash; which framework are we going to use? There are numerous articles on the Internet that describe pros and cons of those. Read this for example: <a href="http://www.netmagazine.com/features/essential-javascript-top-five-testing-libraries">http://www.netmagazine.com/features/essential-javascript-top-five-testing-libraries</a>.</p>

<p>I personally prefer <a href="http://pivotal.github.io/jasmine/">Jasmine</a> and <a href="http://visionmedia.github.io/mocha/">Mocha</a> (coupled with CoffeeScript and <a href="http://chaijs.com">Chai</a> they feel so much like RSpec). But it&rsquo;s only a matter of taste in fact. Their capabilities are more or less equal.</p>

<p>Let&rsquo;s say we have a framework. Then we can manually create HTML file, include JS we want to test, open it in a browser and, well, test. It&rsquo;s certainly a kind of automatic testing already but still so far away from something reasonable. And the first thing to think about is Continuous Integration. You can only run such tests manually and see the results with your eyes. No &ldquo;on-commit runs&rdquo;, no Travis integration. Sadness.</p>

<h4>PhantomJS</h4>

<p><a href="http://phantomjs.org">Phantom</a> is a thing that solves that. It&rsquo;s a headless invisible browser that you can control programmatically. Like this for example: <a href="https://github.com/ariya/phantomjs/blob/master/examples/colorwheel.js">https://github.com/ariya/phantomjs/blob/master/examples/colorwheel.js</a>. <strong>Phantom</strong> will play the role of our eyes and hands &mdash; it will open a page, check the results and pass them back to a &ldquo;script runner&rdquo;. The &ldquo;script runner&rdquo; that can run on commit or at Travis.</p>

<h4>Grunt</h4>

<p><img src="http://gruntjs.com/img/grunt-logo.png" style="float: right; margin-left: 10px; height: 80px"></p>

<p>And the &ldquo;script runner&rdquo; in its turn is <a href="http://gruntjs.com">Grunt</a>. Did you use <strong>Grunt</strong> before? <a href="http://gruntjs.com/getting-started">Go and try</a> if you did not &mdash; it&rsquo;s incredible. <strong>Grunt</strong> comes with <a href="https://github.com/cowboy/jquery-tiny-pubsub/">sample project</a> showing its main features. And guess what? It has testing section! The sample project uses <a href="http://qunitjs.com">QUnit</a>. Here we see:</p>

<ul>
<li><a href="https://github.com/cowboy/jquery-tiny-pubsub/blob/master/test/tiny-pubsub.html">hand-made HTML testing playground</a></li>
<li><a href="https://github.com/cowboy/jquery-tiny-pubsub/blob/master/test/tiny-pubsub_test.js">single test file</a></li>
<li><a href="https://github.com/cowboy/jquery-tiny-pubsub/blob/master/Gruntfile.js#L80">external plug-in <strong>grunt-contrib-qunit</strong>&hellip;</a></li>
<li><a href="https://github.com/cowboy/jquery-tiny-pubsub/blob/master/Gruntfile.js#L37-L39">&hellip;and its configuration</a></li>
</ul>


<p>Unlike this one, most of real projects do not keep HTML playground manually crafted. They use another (more powerful) <strong>Grunt</strong> plug-ins allowing to generate that on the fly. Combining all that we have a <strong>Grunt</strong> task that:</p>

<ol>
<li> generates page with test</li>
<li> runs <strong>Phantom</strong></li>
<li> grabs the result</li>
<li> prints it to console</li>
<li> exits with proper code (whether test succeeded)</li>
</ol>


<p>That&rsquo;s pretty much it. This is exactly how Javascript front-end testing works basically. And it has some issues that you either experienced already or are going to experience.</p>

<h3>Part 2. Basic stuff and issues</h3>

<blockquote><p>Have you already automated tests that run in both, console and browsers? If you already know the pains and just want a cure &mdash; pass on to the Part 3.</p></blockquote>

<p>It&rsquo;s pretty easy to organize tests like its described in Part 1. It&rsquo;s a common way to solve the issue and there are tons of ready-made <strong>Grunt</strong> plug-ins for any framework no matter which one you use. Seriously, take a look at these for example:</p>

<ul>
<li><a href="https://github.com/gruntjs/grunt-contrib-jasmine">grunt-contrib-jasmine</a> (I used this one before)</li>
<li><a href="https://github.com/kmiyashiro/grunt-mocha">grunt-mocha</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-qunit">grunt-contrib-qunit</a></li>
</ul>


<p>Alright! Isn&rsquo;t that simple? Install the plug-in, drop couple lines into a config, add proper runner to <code>.travis.yml</code>. That&rsquo;s it. Flawless victory. Victory? Doh&hellip;</p>

<h4>Development mode</h4>

<p>Single runs are working now. But that&rsquo;s just a start. To keep development process away from the &ldquo;switch a window&rdquo; game runners are supposed to watch modifications of the test files and restart tests automatically. Here comes <a href="https://github.com/gruntjs/grunt-contrib-watch">grunt-contrib-watch</a>! Right? Another entry to config and we are done &mdash; <strong>Grunt</strong> keeps process running and every time you save a file it runs test runner from scratch.</p>

<p>In simple cases (if we forgive <strong>watch</strong> its bugginess) it saves indeed. Let&rsquo;s just keep it in mind for now: we have the development mode and it utilizes <strong>watch</strong> internally.</p>

<h4>Bundling</h4>

<p>Libraries happen to be big. And sometimes even huge. But even mid-sized libraries typically use more then one file. And as you know front-end JS can&rsquo;t bundle itself, something has to help it (and this &ldquo;something&rdquo; probably runs from <strong>Grunt</strong> as well).</p>

<p>It means that before we actually test our code we have to bundle it. No probs you say, <strong>Grunt</strong> can hook tasks. We just make it run bundling task before the tests run. And now do you remember we have a development mode with <strong>watch</strong>? So we have to bundle code every single time we press Save in the editor and/or file changes. How long does it take to bundle your code once? ;)</p>

<p>With such approach <strong>watch</strong> really starts to drive crazy. It misses saves, crashes and every time you look at the console with the results of tests you have literally no idea &mdash; WHAT are you looking at. Are those results of the latest tests? Or is it bundling right now and the new run is yet to come? Did it even catch the last save? Finally you end up switching back to manual runs.</p>

<h4>CoffeeScript</h4>

<p>But even if you don&rsquo;t we are still not there yet. If your application is in CoffeeScript or another dialect, you probably use the same language for specs. So you have to compile them too. Now you have to compile both &mdash; your app and EVERY test file you have on EACH test run. Should I say there are can be MUCH more test files than application files? So how long did you say it takes to bundle your code?</p>

<p>Wait. Can&rsquo;t we only recompile files that actually changed? Not really. <strong>watch</strong> simply can&rsquo;t do that. And none of existing workarounds help with modern version unfortunately. The only thing that works (if you can call that <em>works</em>) is full recompilation on each change.</p>

<h4>Run with something else but Phantom</h4>

<p>In the real life nobody is going to use your code in <strong>PhantomJS</strong>. From time to time you have to check it with real browsers anyway. To do that we should manually open HTML that was generated by runner in the browser we target. If you are unlucky enough to deal with things that behave differently in different browsers you get back to the start. To the &ldquo;switch a window&rdquo; game.</p>

<p>It&rsquo;s not a 100% of cases for sure. Not even 50% of them. Is that what you might be thinking. At least so did I before I experienced it for the first time. And the circle has closed.</p>

<h3>Part 3. Testem, Mincer and the way they integrate</h3>

<p><a href="github.com/airportyh/testem/">Testem</a> is simply awesome. Really. It&rsquo;s so incredible I can&rsquo;t even describe what I felt when I tried it first. Just watch this:</p>

<iframe width="560" height="315" src="http://archive.staal.io//www.youtube.com/embed/-1mjv4yk5JM" frameborder="0" allowfullscreen style="margin-top: 20px; margin-bottom: 20px;"></iframe>


<p><strong>Testem</strong> completely removes the difference between headless console runs and real browsers. Things just get bundled into a big ecosystem with single large green &ldquo;CHECK&rdquo; button. And I was happy until I tried to use it with a real project&hellip;</p>

<p>The marketing lies! Well&hellip; A little bit at least. <strong>Testem</strong> says it supports preprocessing. No it does not. I mean it does in some way &mdash; it allows you to run custom bash command before each test run and after that. It states it&rsquo;s possible to do anything from command line. Well&hellip; Technically it is. It&rsquo;s also technically possible to cross an ocean riding a dolphin.</p>

<hr />

<p>But I didn&rsquo;t give up! Despite this limitation <strong>Testem</strong> still has a lot of stuff to support. At least we are going to solve the problem with manual browsers checking. This alone is a huge step forward. Yet another disappointment &mdash; <strong>Testem</strong> absolutely is (was!) not adapted for external programmatic integration. It&rsquo;s all kinda selfish and independent. So I did this:</p>

<p><strong>I wrote a Grunt task that was running Testem that was running bash script that was running Grunt that was compiling Coffee.</strong></p>

<p>We need to go deeper!.. This approach appeared to work even worse then before. So I took scalpel and forked <strong>Testem</strong>.</p>

<h4>Resulting solution</h4>

<p><strong>Testem</strong> is perfect when it comes to:</p>

<ol>
<li>Support of different testing frameworks</li>
<li>Headless runs using ready JS files</li>
<li>Watching set of files to rerun tests automatically</li>
<li>Integration with real browsers of your OS</li>
</ol>


<p>We simply have to make it work through some kind of an API and make it include Javascript files from some kind of storage that handles preprocessing (handles incredibly fast and efficiently by splitting code in atomic parts and recompiling only things that changed).</p>

<p>In couple days me and <a href="https://github.com/airportyh/">Toby</a> approved and introduced all the required API modifications. New version of <strong>Testem</strong> can:</p>

<ul>
<li>Accept configuration from API calls. Config file is not required anymore.</li>
<li>Accept hooks as JS functions (instead of bash strings that run X that runs Y that runs&hellip;)</li>
<li>Pass data to hooks</li>
<li>Run <code>on_change</code> event when <strong>Testem</strong> notices file modification</li>
<li>Include JS from URLs not just paths</li>
<li>Override forced process destruction in the end of tests</li>
</ul>


<p>And as a bonus new version supports Javascript configuration files (testem.js).</p>

<p>Okay then. Here I come, storage. At 1.2 branch of <a href="http://joosy.ws">Joosy</a> we have adapted <a href="https://github.com/nodeca/mincer">Mincer</a> to manage internal dependencies. And that&rsquo;s exactly the storage we need in fact. It suits us simply perfect. Here is the resulting workflow:</p>

<p><img src="https://github-camo.global.ssl.fastly.net/800e21517caf421200ca027c0bd50da0a5b913f1/687474703a2f2f662e636c2e6c792f6974656d732f30513275327632633143316531333252334c33332f636c6f75642e706e67" style="float: left; margin-right: 40px;"></p>

<ol style="clear: none;">
  <li>Start <a href="http://www.senchalabs.org/connect/">connect.js</a> on the port X and serve Mincer middleware</li>
  <li>Take a list of paths including paths to Coffee, CoCo (anything Mincer can handle), expand UNIX masks and build the resulting list of files that <b>Testem</b> should watch modifications for</li>
  <li>Map list of files to the list of URLs: http://localhost:X/path</li>
  <li>Pass watch and serve lists to <b>Testem</b> and run it.</li>
</ol>




<br style="clear: both">


<p>As the result <strong>Testem</strong> watches modification of original files but it doesn&rsquo;t include them directly. Instead it includes them through <strong>Mincer</strong> that is listening the neighbor port. And <strong>Mincer</strong> in its turn handles all compilations and caching.</p>

<p>I have to say here that <strong>Mincer</strong> isn&rsquo;t just fast. It&rsquo;s incredibly smart when it comes to caching. You can rest assured that at any moment you get actual code for any file. But what&rsquo;s really important it has nothing to do with <strong>Testem</strong>. Even if it takes a while to compile all your code (which happens on the first run) &mdash; it&rsquo;s browser that waits. It makes <strong>Testem</strong> watcher feel relaxed and work well. It also means that at any time you open console &mdash; you can be sure you see the latest results. You&rsquo;ll just see zero progress if it&rsquo;s compiling right now.</p>

<p>All this stuff is wrapped into a Grunt plug-in. All you have to do to start using it is to install <a href="https://github.com/inossidabile/grunt-contrib-testem">https://github.com/inossidabile/grunt-contrib-testem</a> and list files you want to test at the config like this:</p>

<p>```coffeescript
grunt.initConfig
  testem:</p>

<pre><code>basic:
  src: [
    'bower_components/jquery/jquery.js',
    'spec/spec_helper.coffee',
    'app/**/*.coffee',
    'spec/**/*_spec.coffee'
  ]
  options:
    # Run 8 browsers at parallel
    parallel: 8
</code></pre>

<p>```</p>

<p><img src="http://f.cl.ly/items/0p3P3G0P2t2Y2g0O0G0e/Image%202013.08.18%205%3A00%3A15%20AM.gif" style="float: left; margin-right: 20px;"></p>

<p>And this time it is finally likely to work well. In my case it made me run out of issues with front-end tests completely. I even had to start enjoying this process in fact. What about you?</p>

<hr />

<p>Please send kudos to incredible authors of <strong>Testem</strong> and <strong>Mincer</strong>: <a href="http://github.com/airportyh/">Toby Ho</a>, <a href="https://github.com/puzrin">Vitaly Puzrin</a> and <a href="https://github.com/ixti">Alex Zapparov</a>. Not only they created something valuable but also keep maintaining it so well. I had a chance to interact closely with both of projects. They really deserve it :).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Joosy: alternative approach to browser frameworks]]></title>
    <link href="http://archive.staal.io/blog/2012/06/04/joosy-alternative-approach-to-browser-frameworks/"/>
    <updated>2012-06-04T23:42:00+07:00</updated>
    <id>http://archive.staal.io/blog/2012/06/04/joosy-alternative-approach-to-browser-frameworks</id>
    <content type="html"><![CDATA[<h3>Long story short</h3>

<p>We created a new JS framework that doesn’t clone anything existing but uses slightly different approach. Joosy we call it.</p>

<ul>
<li><a href="http://www.joosy.ws">Joosy website</a></li>
<li><a href="http://guides.joosy.ws/guides/basics/getting-started.html">Getting started guide</a></li>
<li><a href="https://github.com/joosy/joosy">Github Repo</a></li>
</ul>


<h3>Real introduction</h3>

<p>Ourdays even a lazy and his grandmother is doing his own JS MVC framework. The reason is simple: we really need it. The problem, on the other side, is that everyone is just cloning Backbone. There is also Knockout and Ember that went a different way. Still not enough to satisfy sophisticated audience. The problems are different. Some may dislike Handlebars. The others won’t fit general API. It’s a matter of taste after all. The options are always good if you choose between something different.</p>

<!-- more -->


<p>Half of year ago during some of new projects we started a tiny experiment. We took generally another approach to this problem: to consider JS Framework an extension to your backend. It should not be abstracted but exactly the opposite: binded to the server side as tightly as possible. It should replace your backend’s view layer. And be the View, just a View. What you usually call “model” is just a data set binded to the template. And JS logic is simply an extension to the template that makes it sophisticated but doesn’t make it a standalone application. We used Rails as a backend.</p>

<p>To make it real we had to implement all the common things Rails people are used to and properly extend them with the abilities that Rails lack. Better organization of code, new conventions for statefull environment and so on. With that we’ve reproduced forms, helpers and even the HAML everything working right in your browser.</p>

<p>Now that the time has passed and some of that projects are in production, we are ready to release this experiment as a mature feature-rich framework. Called “<a href="http://www.joosy.ws/">Joosy</a>”.</p>

<p>Joosy is based on View terms. Pages, Layouts, Helpers and templates. Inside, it uses <a href="http://coffeescript.org">CoffeScript</a> possibilities massively. To make Coffee better, Joosy includes awesome <a href="http://sugarjs.com">Sugar.JS</a> library that feels like ActiveSupport. So you have better language that is sweetened.</p>

<p>Joosy has everything you are used to within another frameworks but with slightly another sause. It has routing, “models” with identity map, nice structure and much more. Like ActiveSupport, ActiveResource-compatible interface, background generators, preloaders, etc.</p>

<p>The practice shown: it’s very easy to jump in if you are used to Rails. It either does what other claims to do: it definitely saves your time. So no matter if you need this or not, please read through “<a href="http://guides.joosy.ws/guides/basics/getting-started.html">Getting Started</a>” guide. At least we have something new to offer and it won’t be dull. And then, maybe, you’ll find a great use for it :).</p>

<p>Feel free to ask any questions at Stack Overflow using <code>joosy</code> tag. I will be there :)</p>
]]></content>
  </entry>
  
</feed>
